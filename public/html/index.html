<!DOCTYPE html>
<html>
<head>
    <title></title>
    <link rel="stylesheet" type="text/css" href="/stylesheets/style.css">
</head>
<body>
<main id="wrapper">
    <header>
        <div style="width: 100%; display: flex; flex-direction: row; justify-content: flex-end; align-items: center">
            <div class="pids-wrapper">
                <div class="pid"></div>
                <div class="pid"></div>
                <div class="pid"></div>
                <div class="pid"></div>
                <div class="pid"></div>
                <div class="pid"></div>
                <div class="pid"></div>
                <div class="pid"></div>
                <div class="pid"></div>
                <div class="pid"></div>
                <div class="pid"></div>
                <div class="pid"></div>
                <div class="pid"></div>
                <div class="pid"></div>
                <div class="pid"></div>
            </div>
            <button id="playbackLogs" style="width: 120px; height: 20px;">
                PLAYBACK
            </button>
        </div>
    </header>

    <div id="intro" >
        <input type="text" name="deviceName" id="userName" placeholder="please enter desired username..">
        <input type="text" name="roomName" id="roomName" placeholder="please enter room name..">
        <button id="join">Join Room</button>
    </div>
    <div id="transcriber" class="hidden">
        <div id="users">
            <!--<div id="chatBubbles"></div>-->
        </div>
        <div id="content">
        </div>
    </div>
    <div id="currentSpeech">
    </div>
</main>
</body>
</html>


<script src="/socket.io/socket.io.js"></script>
<script src='https://code.responsivevoice.org/responsivevoice.js'></script>
<script>

    let timeOutInterval = 0;
    let counter = 0;
    let socket = io()

    let users = []

    window.join.addEventListener('click', () => {
        socket.emit('join', {
            userName:window.userName.value,
            roomName:window.roomName.value
        })
    })

    socket.on('joined', (data) => {
        recognition.start()
        window.transcriber.classList.toggle('hidden')
        window.intro.classList.toggle('hidden')

        users = data.roomUsers

        console.log(data)

        reinitAvatars()

        document.getElementById(socket.id).scrollIntoView({ behavior: 'smooth', block: 'center' })
    })

    window.playbackLogs.addEventListener('click', async () => { await interactiveMode() })

    socket.on('newUserJoined', data => {
        createMsgElement('System', new Date().getTime(), `${data.userName}: I have joined the conversation`, 1);
        users = data.roomUsers

        reinitAvatars()
    })

    // var test_counter = 0;
    socket.on('speech', (data) => {
        // test_counter++;
        // console.log(test_counter,data.user , data.msg);

        createMsgElement(data.name,data.timestamp,data.message, data.confidence, data.socketid);
        createChatBubble(data.message,data.socketid)
    })

    let currentElement = window.currentSpeech

    const recognition = new webkitSpeechRecognition();
    recognition.continuous = true;
    recognition.interimResults = true;
    //recognition.lang = 'pl';

    recognition.onsoundend = function() {
        // console.log('sound has stopped being detected');
    }

    recognition.onspeechstart = function() {
        // console.log('Speech has been detected');
        counter = 0;
        startCounting();

    }


    function startCounting() {
        clearTimeout(timeOutInterval);
        // console.log("timer Reset " + counter);

		counter++;
		if(counter == 3){
			 console.log("*** time UP");
			clearTimeout(timeOutInterval);
			counter = 0;
			recognition.stop();

        }else{
            timeOutInterval = setTimeout(startCounting,1000);
        }
    }


    recognition.onresult = function(event) {

// if(average > average_high){
// 	average_high = Math.round(average);
// }else if(average < average_low){
// 	average_low = Math.round(average);
// }
// console.log(average);
// console.log(average + " - " +event.results[0][0].transcript + "  ("+Math.floor(event.results[0][0].confidence * 10000) / 100+")");

    	var final_transcript = ''
    	var interim_transcript = ''
        var confidence = 0
        var newline = '\r\n'
    	for (var i = event.resultIndex; i < event.results.length; ++i) {
    	  // console.log(event.results[i][0])
	      if (event.results[i].isFinal) {
	        final_transcript += event.results[i][0].transcript;
	        confidence = event.results[i][0].confidence;
					console.log(Math.floor(event.results[i][0].confidence * 10000) / 100+ " - [" +average_all.toString() +"] : " +event.results[i][0].transcript);
					// average_high = 0;
					// average_low = 1000;
					// average_all = [];
	      } else {
					console.log( Math.floor(event.results[i][0].confidence * 10000) / 100+ " - " + Math.round(average) + " : " +event.results[i][0].transcript);
					average_all.push(Math.round(average));
	        interim_transcript += event.results[i][0].transcript + ' ';
					counter = 0;
					startCounting();
	        confidence = event.results[i][0].confidence;
	      }
	    }

        let d = new Date()

        if (interim_transcript) {
            currentElement.textContent = `${interim_transcript}`
            colorfyConfidence(currentElement, confidence)
	    }
			if (final_transcript) {

			let msg_id = window.userName.value+"_"+guid();
	    // if (final_transcript && Math.floor(confidence * 10000) / 100 >= 80) {
        createMsgElement(window.userName.value,d.getTime(),final_transcript, confidence,msg_id);

	    	currentElement.textContent = ''
				socket.emit('message', {
					room:window.roomName.value,
					message:final_transcript,
					confidence: confidence,
					name: window.userName.value,
					timestamp: new Date().getTime(),
					mic:average_all,
					msgid: msg_id
                socketid: socket.id

				})
				average_all = [];

			}
	    // }else if(Math.floor(confidence * 10000) / 100 >= 80){
				// currentElement.textContent = '';
			// }
    }

    function createMsgElement(user,time,msg, confidence, socketid) {
        let finalElem = document.createElement('span');
        let nl = '\r\n'
        finalElem.textContent = `${user} - ${new Date(time).toLocaleTimeString()} `
        finalElem.textContent += `Confidence: ${Math.floor(confidence * 10000) / 100}%`
        finalElem.textContent += `${nl} ${msg}`
        finalElem.style.whiteSpace = 'pre-line'
        finalElem.dataset.user = user
        finalElem.dataset.time = new Date(time).toLocaleTimeString();
        finalElem.dataset.speech = msg;
        finalElem.dataset.confidence = confidence
        finalElem.dataset.socketid = socketid
        colorfyConfidence(finalElem, confidence)
        window.content.appendChild(finalElem);
        window.content.scrollTop = window.content.scrollHeight;
        //createChatBubble(msg)
    }
		function guid() {
		  return "ss-s-sss".replace(/s/g, s4);
		}

		function s4() {
		  return Math.floor((1 + Math.random()) * 0x10000)
		    .toString(16)
		    .substring(1);
		}

function createMsgElement(user,time,msg, confidence) {
	let finalElem = document.createElement('span');
	let nl = '\r\n'
	finalElem.textContent = `${user} - ${new Date(time).toLocaleTimeString()} `
    finalElem.textContent += `Confidence: ${Math.floor(confidence * 10000) / 100}%`
    finalElem.textContent += `${nl} ${msg}`
    finalElem.style.whiteSpace = 'pre-line'
	finalElem.dataset.time = new Date(time).toLocaleTimeString();
	finalElem.dataset.speech = msg;
	finalElem.dataset.confidence = confidence
	colorfyConfidence(finalElem, confidence)
	window.content.appendChild(finalElem);
	window.content.scrollTop = window.content.scrollHeight;
}

    function createChatBubble(msg, id) {
        let colour = document.getElementById(id).querySelector('.avatar').style.background
        let container = document.createElement('div')
        console.log(colour,'yye')
        container.style.background = colour
        container.style.border = colour
        let text = document.createElement('p')
        container.appendChild(text)
        text.textContent = msg
        container.classList.add('speech-bubble')
        document.getElementById(id).appendChild(container)
        document.getElementById(id).scrollIntoView({ behavior: 'smooth', block: 'center' })

        setTimeout(() => {
            container.remove()
        }, 10000)
    }


    function colorfyConfidence(elem, confidence) {
        var perfect = 'rgb(78, 218, 232)'
        var best = '#bfffbf'
        var avg = '#fbf09e'
        var rubbish = '#fb9e9e'
        var finalColor = null

        if (confidence > 0.93) finalColor = perfect
        else if (confidence < 0.93 && confidence > 0.85) finalColor = best
        else if (confidence < 0.85 && confidence > 0.70) finalColor = avg
        else finalColor = rubbish

        elem.style.background = finalColor
    }

    async function textToSpeech(speech) {
        return new Promise( res => {
            console.log(speech, 'from this fn')
            let engine = new SpeechSynthesisUtterance()
            let voices = window.speechSynthesis.getVoices()
            engine.text = speech.text
            engine.voice = speech.voice ? speech.voice : voices[0]
            engine.rate = speech.rate ? speech.rate : 5
            engine.pitch = speech.pitch ? speech.pitch : 1
            engine.onend = e => res({ finished: true, elapsedTime: e.elapsedTime })
            speechSynthesis.speak(engine)
        })
    }

    async function interactiveMode() {
        recognition.abort()
        let logs = Array.from(window.content.children)
        for (let i = 0; i < logs.length; i++) {

            let log = logs[i]
            console.log(log)
            let said = await textToSpeech({text: `${log.dataset.user} said: `})
            console.log(said)
            createChatBubble(log.dataset.speech, log.dataset.socketid)
            let said2 = await textToSpeech({text: `${log.dataset.speech}`})
            console.log(said2)
        }
    }

    recognition.onend = function(event) {
        // console.log('finished')
        recognition.start()
    }

    recognition.onerror = function(event) {
        // console.log(event.error);
    };


let average = 0

// let average_low = 1000

    function reinitAvatars() {
        let avatars = Array.from(document.querySelectorAll('.avtContainer'))

        for (let i of avatars) {
            i.remove()
        }
let average_all = [];

	navigator.mediaDevices.getUserMedia({ audio: true})
	.then(function(stream) {
	  audioContext = new AudioContext();
	  analyser = audioContext.createAnalyser();
	  microphone = audioContext.createMediaStreamSource(stream);
	  javascriptNode = audioContext.createScriptProcessor(2048, 1, 1);
        for (let i = 0; i < users.length ;i++) {
            console.log(users[i],'here')
            createAvatarForUser(users[i].username.substring(0,1).toUpperCase(), users[i].socketid, users[i].avatarColor)
        }
    }


    navigator.mediaDevices.getUserMedia({ audio: true})
        .then(function(stream) {
            audioContext = new AudioContext();
            analyser = audioContext.createAnalyser();
            microphone = audioContext.createMediaStreamSource(stream);
            javascriptNode = audioContext.createScriptProcessor(2048, 1, 1);

            analyser.smoothingTimeConstant = 0.8;
            analyser.fftSize = 1024;

	      average = values / length;

                var length = array.length;
                for (var i = 0; i < length; i++) {
                    values += (array[i]);
                }

                var average = values / length;

                // console.log(Math.round(average));
                colorPids(average);
            }
        })
        .catch(function(err) {
            /* handle the error */
        });


    function colorPids(vol) {
        let all_pids_node = document.querySelectorAll('.pid');
        let all_pids = Array.from(all_pids_node);

        let amout_of_pids = Math.round(vol/15);
        let elem_range = all_pids.slice(0, amout_of_pids)
        for (var i = 0; i < all_pids.length; i++) {
            all_pids[i].style.backgroundColor="#e6e7e8";
        }
        for (var i = 0; i < elem_range.length; i++) {







socket.on('cancelmsg', (data) => {
	console.log(data);

	var msg = document.getElementById(data);
	if(msg != null){
		msg.classList.add("canceledMsg");
	}
});




    function createAvatarForUser(name, sId, colour) {


        let container = document.createElement('div')
        container.id = sId

        let innerContainer = document.createElement('div')

        innerContainer.classList.add('innerContainer')
        let avatar = document.createElement('div')
        avatar.classList.add('avatar')
        avatar.style.background = colour


        innerContainer.appendChild(avatar)

        let text = document.createElement('span')
        text.textContent = name

        avatar.appendChild(text)

        // let startingPoint = 360 / users.length
        //
        // let angle = startingPoint
        //
        // if (currentNum) {
        //     for (let i = 0;i < currentNum; i++) {
        //         angle += startingPoint
        //     }
        // }

        //container.style.transform = `rotate(${angle}deg) translate(14em) rotate(-${angle}deg)`

        container.classList.add('avtContainer')
        container.appendChild(innerContainer)
        window.users.appendChild(container)
    }



</script>